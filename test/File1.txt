// @tag core
/**
 * @class Kan
 * Javascript framework to do more writing less, as a kanji in japanese.
 * @singleton
 */
(function(w){
	
	var VERSION = "v0.0.1",
		type = {}.toString,
		/**
		 * @member Kan
		 * @method hasOwn
		 */
		hasOwn = {}.hasOwnProperty,
		namespaces = {},
		aliases = {},
		computePreRedrawHook = null,
		computePostRedrawHook = null,
		redrawing = false,
		html,
		documentNode = {
			appendChild: function (node) {
				var doc = Kan.vdom.Manager.$document;
				if (html === undefined) {
					html = doc.createElement("html");
				}

				if (doc.documentElement && doc.documentElement !== node) {
					doc.replaceChild(node, doc.documentElement);
				} else {
					doc.appendChild(node);
				}

				this.childNodes = doc.childNodes;
			},

			insertBefore: function (node) {
				this.appendChild(node);
			},

			childNodes: []
		};

	// lastRedrawId is a positive number if a second redraw is requested before
	// the next animation frame, or 0 if it's the first redraw and not an event
	// handler
	var lastRedrawId = 0;
	var lastRedrawCallTime = 0;

	function actuallyPerformRedraw() {
		var manager = Kan.vdom.Manager;
		if (lastRedrawId > 0) manager.$cancelAnimationFrame(lastRedrawId);
		lastRedrawId = manager.$requestAnimationFrame(redraw, manager.FRAME_BUDGET);
	}

	function performRedraw(){
		if (+new Date() - lastRedrawCallTime > Kan.vdom.Manager.FRAME_BUDGET) {
			actuallyPerformRedraw();
		}
	}

	/**
	 * @member Kan
	 */
	function isFunction(object) {
		return object && typeof object === "function";
	}

	/**
	 * @member Kan
	 */
	function isObject(object) {
		return object && type.call(object) === "[object Object]";
	}

	/**
	 * @member Kan
	 */
	function isString(object) {
		return object && type.call(object) === "[object String]";
	}

	/**
	 * @member Kan
	 */
	function isBoolean(object) {
		return typeof object === "boolean";
	}

	/**
	 * @member Kan
	 */
	function isNumber(object) {
		return typeof object === "number";
	}

	/**
	 * @member Kan
	 * @method
	 */
	var isArray = Array.isArray || function (object) {
		return object && type.call(object) === "[object Array]";
	}

	/**
	 * @member Kan
	 * @method noop
	 * An empty Function
	 */
	function noop() {}

	/**
	 * @member Kan
	 */
	function forEach(list, f) {
		for (var i = 0; i < list.length && !f(list[i], i++);) {
			// empty
		}
	}

	/**
	 * @member Kan
	 */
	function forOwn(obj, f) {
		for (var prop in obj) if (hasOwn.call(obj, prop)) {
			if (f(obj[prop], prop)) break;
		}
	}

	/**
	 * @member Kan
	 */
	function forKeys(list, f) {
		forEach(list, function (attrs, i) {
			attrs = attrs && attrs.attrs;
			return attrs && attrs.key != null && f(attrs, i);
		});
	}

	/**
	 * @member Kan
	 */
	function merge(object, config, defaults, ignoreNulls){
		if (defaults) {
            Kan.merge(object, defaults, null, ignoreNulls);
        }

        if (isObject(object) && isObject(config)) {
            forOwn(config, function(val, prop){
            	if(!ignoreNulls || (ignoreNulls && val != null)){
            		object[prop] = val;
            	}
            });
        }

        return object;
	}

	/**
	 * @member Kan
	 */
	function getNs(name, getprev){
		var ns = w,
			chunks = name.split("."),
			l = chunks.length;

		forEach(chunks,function(n, i){
			if(i == l-1 && getprev) return;
			ns[n] = (ns[n] || {});
			ns = ns[n];
		});
		return ns;
	}

	/**
	 * @member Kan
	 */
	function flatten(list) {
		// recursively flatten array
		for (var i = 0; i < list.length; i++) {
			if (isArray(list[i])) {
				list = list.concat.apply([], list);
				// check current index again while there is an array at this
				// index.
				i--;
			}
		}

		return list
	}

	function redraw() {
		var manager = Kan.vdom.Manager;
		if (computePreRedrawHook) {
			computePreRedrawHook();
			computePreRedrawHook = null;
		}

		forEach(manager.roots, function (root, i) {
			var component = manager.components[i];
			if (component) {
				Kan.render(root, component.view(component));
			}
		});

		// after rendering within a routed context, we need to scroll back to
		// the top, and fetch the document title for history.pushState
		if (computePostRedrawHook) {
			computePostRedrawHook();
			computePostRedrawHook = null;
		}

		lastRedrawId = null;
		lastRedrawCallTime = new Date();
		Kan.redraw.strategy("diff");
	}

	function gettersetter(store) {
		function prop() {
			if (arguments.length) store = arguments[0];
			return store;
		}

		prop.toJSON = function () {
			return store;
		}

		return prop;
	}

	function isNativeError(e) {
		return e instanceof EvalError ||
			e instanceof RangeError ||
			e instanceof ReferenceError ||
			e instanceof SyntaxError ||
			e instanceof TypeError ||
			e instanceof URIError
	}

	// Promiz.mithril.js | Zolmeister | MIT
	// a modified version of Promiz.js, which does not conform to Promises/A+
	// for two reasons:
	//
	// 1) `then` callbacks are called synchronously (because setTimeout is too
	// 	  slow, and the setImmediate polyfill is too big
	// 2) throwing subclasses of Error cause the error to be bubbled up instead
	//    of triggering rejection (because the spec does not account for the
	//    important use case of default browser error handling, i.e. message w/
	//    line number)
	var RESOLVING = 1,
		REJECTING = 2,
		RESOLVED = 3,
		REJECTED = 4;

	function Deferred(onSuccess, onFailure) {
		var self = this,
			state = 0,
			promiseValue = 0,
			next = [];

		self.promise = {};

		self.resolve = function (value) {
			if (!state) {
				promiseValue = value;
				state = RESOLVING;

				fire();
			}
			return this;
		};

		self.reject = function (value) {
			if (!state) {
				promiseValue = value;
				state = REJECTING;

				fire();
			}
			return this;
		};

		self.promise.then = function (onSuccess, onFailure) {
			var deferred = new Deferred(onSuccess, onFailure);
			if (state === RESOLVED) {
				deferred.resolve(promiseValue);
			} else if (state === REJECTED) {
				deferred.reject(promiseValue);
			} else {
				next.push(deferred);
			}
			return deferred.promise;
		}

		function finish(type) {
			state = type || REJECTED;
			forEach(next, function (deferred) {
				if (state === RESOLVED) {
					deferred.resolve(promiseValue);
				} else {
					deferred.reject(promiseValue);
				}
			});
		}

		function thennable(then, success, fail, notThennable) {
			if (((promiseValue != null && isObject(promiseValue)) || isFunction(promiseValue)) && isFunction(then)) {
				try {
					// count protects against abuse calls from spec checker
					var count = 0;
					then.call(promiseValue, function (value) {
						if (count++) return;
						promiseValue = value;
						success();
					}, function (value) {
						if (count++) return;
						promiseValue = value;
						fail();
					});
				} catch (e) {
					m.deferred.onerror(e);
					promiseValue = e;
					fail();
				}
			} else {
				notThennable();
			}
		}

		function fire() {
			// check if it's a thenable
			var then;
			try {
				then = promiseValue && promiseValue.then;
			} catch (e) {
				m.deferred.onerror(e);
				promiseValue = e;
				state = REJECTING;
				return fire();
			}

			if (state === REJECTING) {
				m.deferred.onerror(promiseValue);
			}

			thennable(then, function () {
				state = RESOLVING;
				fire();
			}, function () {
				state = REJECTING;
				fire();
			}, function () {
				try {
					if (state === RESOLVING && isFunction(onSuccess)) {
						promiseValue = onSuccess(promiseValue);
					} else if (state === REJECTING && isFunction(onFailure)) {
						promiseValue = onFailure(promiseValue);
						state = RESOLVING;
					}
				} catch (e) {
					m.deferred.onerror(e);
					promiseValue = e;
					return finish();
				}

				if (promiseValue === self) {
					promiseValue = TypeError();
					finish();
				} else {
					thennable(then, function () {
						finish(RESOLVED);
					}, finish, function () {
						finish(state === RESOLVING && RESOLVED);
					})
				}
			});
		}
	}

	function propify(promise, initialValue) {
		var prop = Kan.prop(initialValue);
		promise.then(prop);

		prop.then = function (resolve, reject) {
			return propify(promise.then(resolve, reject), initialValue);
		}

		prop.catch = prop.then.bind(null, null);

		prop.finally = function (callback) {
			function _callback() {
				return m.deferred().resolve(callback()).promise;
			}

			return prop.then(function (value) {
				return propify(_callback().then(function () {
					return value;
				}), initialValue);
			}, function (reason) {
				return propify(_callback().then(function () {
					throw new Error(reason);
				}), initialValue);
			});
		};

		return prop;
	}

	/**
	 * @class Kan.Base
	 * A base class from which all classes inherit
	 */
	var Base = function(){
		this.$name = "Kan.Base";
		/**
		 * @member Kan.Base
		 * @method constructor
		 * All classes can define a constructor that will be called upon instantiation.
		 * @template
		 */
		this.constructor = noop;
		/**
		 * @member Kan.Base
		 * If a method overrides one of its superclass's methods, the overridden method can be invoked through the use of this method.
		 */
		this.callSuper = function(){
			return (this.callSuper.caller._sm || Kan.noop).call(this,arguments);
		};
	};

	var Kan = {
		guid: 0,

		each: forEach,

		hasOwn: hasOwn,

		noop: noop,

		isBoolean: isBoolean,

		isNumber: isNumber,

		forKeys: forKeys,

		forOwn: forOwn,

		isArray: isArray,

		isString: isString,

		isFunction: isFunction,

		isObject: isObject,

		merge: merge,

		flatten: flatten,

		Base : Base,

		getNewId: function(){
			return Kan.Prefix()+"id-"+(++Kan.guid);
		},

		Prefix: function(){
			return "kjs-";
		},

		/**
		 * @member Kan
		 */
		isEqualType: function(a,b){
			return type.call(a) === type.call(b);
		},

		/**
		 * @member Kan
		 */
		Version: function(){
			return VERSION;
		},

		/**
		 * @member Kan
		 */
		define: function(name, definition){
			var ns = getNs(name);
			ns = namespaces[name] = definition;

			if(ns.singleton){
				// This way it will be created just once.
				namespaces[name].singleton = false;
				namespaces[name] = Kan.new(name);
				namespaces[name].singleton = true;
				
				var chunks = name.split("."),
					nsName = chunks[chunks.length-1];

				ns = getNs(name, true);
				ns[nsName] = namespaces[name];

			}else if(isString(ns.alias)){
				aliases[ns.alias] = name;
			}
		},

		/**
		 * @member Kan
		 */
		new: function(name, cfg){
			if(!namespaces[name]) throw new Error(name + " is not Defined");
			var cls = namespaces[name];

			if(!isFunction(cls) && !cls.singleton){
				var proto = cls.extend ? Kan.new(cls.extend) : new Kan.Base(),
					defaults = {},
					chunks = name.split("."),
					nsName = chunks[chunks.length-1],
					ns = getNs(name, true);

				forOwn(cls, function(val, prop){
					if(prop == "extend") return;
					if(isFunction(val)){
						//super method
						var sm = null;
						if(prop in proto){
							sm = proto[prop];
						}
						proto[prop] = val;
						proto[prop].$name = prop;
						proto[prop]._sm = sm;
					}else{
						defaults[prop] = val;
					}
				});

				ns[nsName] = function(config){
					var me = this;
					me.$className= name;
					me.$config   = config;
					me.$defaults = defaults;
					me.$created = true;
					merge(me, config || {}, defaults);
					this.constructor();
				};
				ns[nsName].prototype = proto;
				namespaces[name] = ns[nsName];
			}

			return cls.singleton ? cls : new namespaces[name](cfg);
		},

		getByAlias: function(alias, cfg){
			var name = aliases[alias];
			if(!name){
				throw new Error("Definition for "+alias+"is missing.");
			}
			return Kan.new(name,cfg);
		},

		startComputation: function () {
			Kan.vdom.Manager.pendingRequests++;
		},

		endComputation: function () {
			if (Kan.vdom.Manager.pendingRequests > 1) {
				Kan.vdom.Manager.pendingRequests--;
			} else {
				Kan.vdom.Manager.pendingRequests = 0;
				Kan.redraw();
			}
		},

		endFirstComputation: function() {
			if (Kan.redraw.strategy() === "none") {
				Kan.vdom.Manager.pendingRequests--;
				Kan.redraw.strategy("diff");
			} else {
				Kan.endComputation();
			}
		},

		trust: function (value) {
			value = new String(value); // eslint-disable-line no-new-wrappers
			value.$trusted = true;
			return value;
		},

		render: function (root, cell, forceRecreation) {
			if (!root) {
				throw new Error("Ensure the DOM element being passed to Kan.route/Kan.bootstrap/Kan.render is not undefined.");
			}

			var configs = [];
			var id = Kan.vdom.Manager.getCellCacheKey(root);
			var isDocumentRoot = root === Kan.vdom.Manager.$document;
			var node;

			if (isDocumentRoot || root === Kan.vdom.Manager.$document.documentElement) {
				node = documentNode;
			} else {
				node = root;
			}

			if (isDocumentRoot && cell.tag !== "html") {
				cell = {tag: "html", attrs: {}, children: cell};
			}

			if (Kan.vdom.Manager.cellCache[id] === undefined) Kan.vdom.Manager.clear(node.childNodes);
			if (forceRecreation === true) Kan.vdom.Manager.reset(root);

			Kan.vdom.Manager.cellCache[id] = Kan.vdom.Manager.build(node, null, undefined, undefined, cell, Kan.vdom.Manager.cellCache[id], false, 0, null, undefined, configs);

			Kan.each(configs, function (config) { config() });
		},

		bootstrap: function (root, component) {
			if (!root) {
				throw new Error("Please ensure the DOM element exists before rendering a template into it.");
			}
			var manager = Kan.vdom.Manager;
			var index = manager.roots.indexOf(root);
			if (index < 0) index = manager.roots.length;

			var isPrevented = false;

			var ev = {
				preventDefault: function () {
					isPrevented = true;
					computePreRedrawHook = computePostRedrawHook = null;
				}
			}

			forEach(manager.unloaders, function (unloader) {
				unloader.handler.call(unloader.component, ev);
				unloader.component.onunload = null;
			});

			if (isPrevented) {
				forEach(manager.unloaders, function (unloader) {
					manager.unloader.component.onunload = unloader.handler;
				});
			} else {
				manager.unloaders = [];
			}

			if (manager.components[index] && isFunction(manager.components[index].onunload)) {
				manager.components[index].onunload(ev);
			}

			return manager.initComponent(component, root, index, isPrevented);
		},

		redraw: function (force) {
			var manager = Kan.vdom.Manager;
			if (redrawing) return;
			redrawing = true;
			if (force) manager.forcing = true;
			try {
				if (lastRedrawId && !force) {
					// when setTimeout:
					// only reschedule redraw if time between now and previous redraw is bigger
					// than a frame, otherwise keep currently scheduled timeout
					//
					// when rAF:
					// always reschedule redraw
					(manager.$requestAnimationFrame === w.requestAnimationFrame ? actuallyPerformRedraw : performRedraw)();
						
				} else {
					redraw();
					lastRedrawId = manager.$requestAnimationFrame(function () {
						lastRedrawId = 0;
					}, manager.FRAME_BUDGET);
				}

			}catch (e){
				//
			} finally {
				redrawing = manager.forcing = false;
			}
		},

		prop: function (store) {
			if ((store != null && isObject(store) || isFunction(store)) && isFunction(store.then)) {
				return propify(store);
			} else {
				return gettersetter(store);
			}
		},

		deferred: function () {
			var deferred = new Deferred();
			deferred.promise = propify(deferred.promise);
			return deferred;
		}
	};

	Kan.deferred.onerror = function (e) {
		if (isNativeError(e)) {
			Kan.vdom.Manager.pendingRequests = 0;
			throw e;
		}
	}

	Kan.redraw.strategy = Kan.prop();

	w.Kan = Kan;
	/**
	 * @member Kan
	 * A reference to the window object
	 */
	Kan.Window = w;
})(typeof window !== "undefined" ? window : global);